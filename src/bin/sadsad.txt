 /**
     * Takes array of chars and creates HashMap of
     * keys(coordinates) and values(Node)
     * @see  Class Node(Stack s,NodeLink[] n,char c)
     * @param Index The array of chars indexes of every node.
     * @return void
     */
    public void createGrid(char[] Index) {
        IndexVal = new double[maxX][maxY];
        for (int j = 0; j < maxY; ++j) {
            for (int i = 0; i < maxX; ++i) {
                IndexVal[i][j] = switch (Index[(j * maxX) + i]) {
                    case 'H' -> 0.5;
                    case 'B' -> 1;
                    case 'S' -> 2;
                    default -> 1000000;
                };
            }
        }
        for (int i = 0; i < Index.length; i++) {
            coordinates = new int[2];
            coordinates[0] = i % maxX;
            coordinates[1] = i / maxX;
            map.put(coordinates, new Node(new Stack(stackSize), createLinks(coordinates, IndexVal), Index[i]));
        }
    }
    /**
     * Takes products in list and places them in designated Nodes.
     * @param productPlacement The list of strings each string contains product and his position.
     * @see  Class Node(Stack s,NodeLink[] n,char c)
     * @return The square root of the given number.
     */
    public void fillGrid(List<String[]> productPlacement) {
        int[] itemXY = new int[2];
        int itemZ;
        String itemName;

        for (String[] strings : productPlacement) {
            if(strings[0]==null) break;
            itemName = strings[0];
            itemXY[0] = Integer.parseInt(strings[1]);
            itemXY[1] = Integer.parseInt(strings[2]);
            itemZ = Integer.parseInt(strings[3]);

            getNode(itemXY).getStack().getVector().setElementAt(itemName, itemZ);
        }
    }
    /**
     * Takes coordinates and movementValues and creates links for every node to aside nodes.
     * @param coordinates The coordinates.
     * @param movementValues The time needed to travel each node.
     * @return The square root of the given number.
     */

    /**
     * Takes files and check if results from file are same as results from program.
     * @param myFileGrid The file grid set up.
     * @param myFileBot The file job set up.
     * @param myFileResult The file result check.
     */
    public ReadWriteFiles(File myFileGrid, File myFileBot, File myFileResult)  {

        ReadGridSetUpFile(myFileGrid);
ReadGridSetUpFile(myFileGrid);
        ReadJobFile(myFileBot);
       ;
        ReadResultFile(myFileResult);
        try {
            WriteResult();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * Writes result file output.txt
     * @return void
     */
    private void WriteResult() throws IOException {
        FileWriter outputResults = new FileWriter("output.txt");
        outputResults.write(algo.results.nodesTraveled()+"\n");
        outputResults.write(algo.results.time()+"\n");

        for(int i = algo.results.nodesIndexesTraveled().size()-1; i>=0; i--) {
            outputResults.write(algo.results.nodesIndexesTraveled().get(i)[0]+" "+ algo.results.nodesIndexesTraveled().get(i)[1]+"\n");
        }

        outputResults.close();
    }

    /**
     * Takes file and setup grid.
     * @param myFile The file grid set up.
     * @return void
     */
    private void ReadGridSetUpFile(File myFile)  {
        try{scan = new Scanner(new FileReader(myFile));}
        catch(FileNotFoundException e){
            System.out.println("File1 not found");
        }
        List<Integer> readCoordinates= new ArrayList<>();

        itemPlacement = new String[4];
        List<String[]> readItemPlacement= new ArrayList<>() ;

        quot=scan.nextLine().split(" ");
        for(String i:quot) {
            readCoordinates.add(Integer.parseInt(i));
        }
        StringJoiner readStrIndexes = new StringJoiner("");
        counter=0;
        while (counter < readCoordinates.get(1) && scan.hasNextLine()) {
            readStrIndexes.add(scan.nextLine());
            counter++;
        }
        readIndexes= readStrIndexes.toString().toCharArray();
        counter = 0;

        while (scan.hasNextLine()) {

            itemPlacement = scan.nextLine().split(" ", 4);
            counter++;


            readItemPlacement.add(itemPlacement);
        }
        grid = new Grid(readCoordinates);
        grid.createGrid(readIndexes);
        grid.fillGrid(readItemPlacement);
        scan.close();
    }
    /**
     * Takes file and setup bot path.
     * @param myFile The file bot setup.
     * @return void
     */
    private void ReadJobFile(File myFile)  {
        try{scan = new Scanner(new FileReader(myFile));}
        catch(FileNotFoundException e){
            System.out.println("File2 not found");
        }
        algo = new FindingAlgorithm(grid);
        String product;
        int[] bot= new int[2];
        int[] station = new int[2];


        quot=scan.nextLine().split(" ");
        bot[0] = Integer.parseInt(quot[0]);
        bot[1] = Integer.parseInt(quot[1]);

        quot=scan.nextLine().split(" ");
        station[0] = Integer.parseInt(quot[0]);
        station[1] = Integer.parseInt(quot[1]);

        product=scan.nextLine();
        algo.findEfficientPath(bot,station,product);

        System.out.println("Product at:  "+ Arrays.toString(algo.results.productCoords())+"  |   time: "+ algo.results.time()+" lenghtInNodes: "+ algo.results.nodesTraveled());
        for(int[] i: algo.results.nodesIndexesTraveled())
            System.out.print("  "+ Arrays.toString(i));
        scan.close();

    }
    /**
     * Takes result file read it.
     * @param myFile The file results.
     * @return void
     */